# TODO

- integrate VoltageMonitors into neurons
- (?) make weight plot functions accept axes and drow on them, thus making
    several plots on the same figure possible
- (?) create a small network object
- use ipynb for demos, print configurations (add repr to basesetup? as_dict)
+ check dimensions for the weights plot
- remove base configurations
- split setup.models into several modules
- test network script



# NEST overall comments

- functions accept objects of different types (like Connect etc.) you can put
    whatever garbage in there
- all parameters are just nested dicts (hey, why do we have OOP?) why don't we
    write a single function called run() and pass all parameters as dict there?
    It's insanely hard to find the right parameter dicts and understand what
    do they mean
- all functions return IDs not objects (insane!) how do I control staff?!
- usually the return value is a list even if a single object was
    created/updated. Same with single input parameters. WTF?
- the permanent use of a global state is a killer..
- model customization is implemented as a "copy" function instead of
    inheritance, which is a great limit comparing to OOP
- pollution of the stdout instead of logging
- pollution of the stdout changes depending on the global state (it grows..)
- there is no way to delete things. Useful in many cases


# simulation configuration management

- pypet - in development + hardly uses global state
